# 枚舉

使用枚舉我們可以定義一些有名字的數字常量。
枚舉通過`enum`關鍵字來定義。

```ts
enum Direction {
    Up = 1,
    Down,
    Left,
    Right
}
```

一個枚舉類型可以包含零個或多個枚舉成員。
枚舉成員具有一個數字值，它可以是*常數*或是*計算得出的值*
當滿足如下條件時，枚舉成員被當作是常數：

* 不具有初始化函數並且之前的枚舉成員是常數。
    在這種情況下，當前枚舉成員的值為上一個枚舉成員的值加1。
    但第一個枚舉元素是個例外。
    如果它沒有初始化方法，那麼它的初始值為`0`。
* 枚舉成員使用*常數枚舉表達式*初始化。
    常數枚舉表達式是TypeScript表達式的子集，它可以在編譯階段求值。
    當一個表達式滿足下面條件之一時，它就是一個常數枚舉表達式：
    * 數字字面量
    * 引用之前定義的常數枚舉成員（可以是在不同的枚舉類型中定義的）
        如果這個成員是在同一個枚舉類型中定義的，可以使用非限定名來引用。
    * 帶括號的常數枚舉表達式
    * `+`, `-`, `~` 一元運算符應用於常數枚舉表達式
    * `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `>>>`, `&`, `|`, `^` 二元運算符，常數枚舉表達式做為其一個操作物件
    若常數枚舉表達式求值後為`NaN`或`Infinity`，則會在編譯階段報錯。

所有其它情況的枚舉成員被當作是需要計算得出的值。

```ts
enum FileAccess {
    // constant members
    None,
    Read    = 1 << 1,
    Write   = 1 << 2,
    ReadWrite  = Read | Write
    // computed member
    G = "123".length
}
```

枚舉是在運行時真正存在的一個物件。
其中一個原因是因為這樣可以從枚舉值到枚舉名進行反向映射。

```ts
enum Enum {
    A
}
let a = Enum.A;
let nameOfA = Enum[Enum.A]; // "A"
```

編譯成：

```js
var Enum;
(function (Enum) {
    Enum[Enum["A"] = 0] = "A";
})(Enum || (Enum = {}));
var a = Enum.A;
var nameOfA = Enum[Enum.A]; // "A"
```

生成的代碼中，枚舉類型被編譯成一個物件，它包含雙向映射（`name` -> `value`）和（`value` -> `name`）。
引用枚舉成員總會生成一次屬性訪問並且永遠不會單行內。
在大多數情況下這是很好的並且正確的解決方案。
然而有時候需求卻比較嚴格。
當訪問枚舉值時，為了避免生成多餘的代碼和間接引用，可以使用常數枚舉。
常數枚舉是在`enum`關鍵字前使用`const`修飾符。

```ts
const enum Enum {
    A = 1,
    B = A * 2
}
```

常數枚舉只能使用常數枚舉表達式並且不同於常規的枚舉的是它們在編譯階段會被刪除。
常數枚舉成員在使用的地方被單行內進來。
這是因為常數枚舉不可能有計算成員。

```ts
const enum Directions {
    Up,
    Down,
    Left,
    Right
}

let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]
```

生成後的代碼為：

```js
var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];
```

# 外部枚舉

外部枚舉用來描述已經存在的枚舉類型的形狀。

```ts
declare enum Enum {
    A = 1,
    B,
    C = 2
}
```

外部枚舉和非外部枚舉之間有一個重要的區別，在正常的枚舉裡，沒有初始化方法的成員被當成常數成員。
對於非常數的外部枚舉而言，沒有初始化方法時被當做需要經過計算的。